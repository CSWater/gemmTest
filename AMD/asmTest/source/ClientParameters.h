/*******************************************************************************
* Copyright (C) 2016 Advanced Micro Devices, Inc. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell cop-
* ies of the Software, and to permit persons to whom the Software is furnished
* to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IM-
* PLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNE-
* CTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*******************************************************************************/

/**************************************************
* This file was generated by Tensile:             *
* https://github.com/ROCmSoftwarePlatform/Tensile *
**************************************************/


#include "Solutions.h"

typedef enum {
    enum_float,
    enum_double,
    enum_TensileComplexFloat,
    enum_TensileComplexDouble
#ifdef Tensile_ENABLE_HALF
    ,enum_TensileHalf
#endif
    ,enum_TensileInt8x4
    ,enum_TensileInt32
} DataTypeEnum;

// Debug Params
const unsigned printTensorA=0;
const unsigned printTensorB=0;
const unsigned printTensorC=0;
const bool printWinnersOnly=false;

const char indexChars[19] = "IJKLMNOPQRSTUVWXYZ";
unsigned int functionIdx;
unsigned int dataTypeIdx;
unsigned int problemTypeIdx;

/* data types */
const unsigned int numDataTypes = 1;
const DataTypeEnum dataTypeEnums[numDataTypes] = { enum_double };
const unsigned int bytesPerElement[numDataTypes] = { 8 };
const unsigned int numFlopsPerMac[numDataTypes] = { 2 };
#define Tensile_DATA_TYPE_DOUBLE
/* problem types */
const unsigned int numProblemTypes = 1;
const unsigned int numIndicesC[numProblemTypes] = { 3 };
const unsigned int numIndicesAB[numProblemTypes] = { 3 };
const unsigned int maxNumIndicesAB = 3;
const unsigned int indexAssignmentsA[numProblemTypes][maxNumIndicesAB] = {
  { 0, 3, 2 }
};
const unsigned int indexAssignmentsB[numProblemTypes][maxNumIndicesAB] = {
  { 1, 3, 2 }
};
bool useBeta[numProblemTypes] = { true };
const bool complexConjugateA[numProblemTypes] = { false };
const bool complexConjugateB[numProblemTypes] = { false };

const unsigned int maxNumIndices = 4;
const unsigned int totalIndices[numProblemTypes] = { 4 };
const unsigned int numProblems = 10;
const unsigned int problemSizes[numProblems][4] = {
  {40704, 2048,    1,  384 },
  {41088, 2048,    1,  384 },
  {41472, 2048,    1,  384 },
  {41856, 2048,    1,  384 },
  {42240, 2048,    1,  384 },
  {42624, 2048,    1,  384 },
  {43008, 2048,    1,  384 },
  {43392, 2048,    1,  384 },
  {43776, 2048,    1,  384 },
  {44160, 2048,    1,  384 }};
const unsigned int minStrides[4] = {0, 0, 0, 0};
/* problem sizes */
size_t maxSizeC = 90439680;
size_t maxSizeA = 16957440;
size_t maxSizeB = 786432;

/* current problem size */

typedef TensileStatus (*SolutionFunctionPointer)(
  double * dataC,
  const double * dataA,
  const double * dataB,
  double alpha,
  double beta,
  unsigned int offsetC,
  unsigned int offsetA,
  unsigned int offsetB,
  unsigned int strideC1J,
  unsigned int strideC2K,
  unsigned int strideA1L,
  unsigned int strideA2K,
  unsigned int strideB1L,
  unsigned int strideB2K,
  unsigned int sizeI,
  unsigned int sizeJ,
  unsigned int sizeK,
  unsigned int sizeL,
  hipStream_t stream,
  unsigned int numInputEvents,
  hipEvent_t * inputEvents,
  hipEvent_t * outputEvent);

struct ClientSolutionInfo {
  SolutionFunctionPointer functionPtr;
  const char *            name;
  int                     assertSummationElementMultiple;
  int                     assertFree0ElementMultiple;
  int                     assertFree1ElementMultiple;
};
/* solutions */
const unsigned int maxNumSolutions = 1;
float solutionPerf[numProblems][maxNumSolutions]; // milliseconds

static const ClientSolutionInfo solutions[maxNumSolutions] = {
  {Cijk_Ailk_Bjlk_DB_MT096x032x08_NLCA03_NLCB01_TT06_04_USFGRO0_WG16_08_01, "Cijk_Ailk_Bjlk_DB_MT096x032x08_NLCA03_NLCB01_TT06_04_USFGRO0_WG16_08_01~", 1, 1, 1}
};
//static const ClientSolutionInfo solutions[maxNumSolutions] = {
//  {Cijk_Ailk_Bjlk_DB_MT064x032x04_NLCA01_NLCB01_TT04_04_USFGRO0_WG16_08_01, "Cijk_Ailk_Bjlk_DB_MT064x032x04_NLCA01_NLCB01_TT04_04_USFGRO0_WG16_08_01~", 1, 1, 1},
//  {Cijk_Ailk_Bjlk_DB_MT032x064x04_NLCA01_NLCB01_TT04_04_USFGRO0_WG08_16_01, "Cijk_Ailk_Bjlk_DB_MT032x064x04_NLCA01_NLCB01_TT04_04_USFGRO0_WG08_16_01~", 1, 1, 1},
//  {Cijk_Ailk_Bjlk_DB_MT064x064x04_NLCA01_NLCB01_TT04_04_USFGRO01_WG16_16_01, "Cijk_Ailk_Bjlk_DB_MT064x064x04_NLCA01_NLCB01_TT04_04_USFGRO01_WG16_16_01~", 1, 1, 1},
//  {Cijk_Ailk_Bjlk_DB_MT064x032x08_NLCA01_NLCB01_TT04_04_USFGRO0_WG16_08_01, "Cijk_Ailk_Bjlk_DB_MT064x032x08_NLCA01_NLCB01_TT04_04_USFGRO0_WG16_08_01~", 1, 1, 1},
//  {Cijk_Ailk_Bjlk_DB_MT096x032x08_NLCA03_NLCB01_TT06_04_USFGRO0_WG16_08_01, "Cijk_Ailk_Bjlk_DB_MT096x032x08_NLCA03_NLCB01_TT06_04_USFGRO0_WG16_08_01~", 1, 1, 1},
//  {Cijk_Ailk_Bjlk_DB_MT032x064x08_NLCA01_NLCB01_TT04_04_USFGRO0_WG08_16_01, "Cijk_Ailk_Bjlk_DB_MT032x064x08_NLCA01_NLCB01_TT04_04_USFGRO0_WG08_16_01~", 1, 1, 1},
//  {Cijk_Ailk_Bjlk_DB_MT032x096x08_NLCA01_NLCB03_TT04_06_USFGRO0_WG08_16_01, "Cijk_Ailk_Bjlk_DB_MT032x096x08_NLCA01_NLCB03_TT04_06_USFGRO0_WG08_16_01~", 1, 1, 1},
//  {Cijk_Ailk_Bjlk_DB_MT064x064x08_NLCA01_NLCB01_TT04_04_USFGRO0_WG16_16_01, "Cijk_Ailk_Bjlk_DB_MT064x064x08_NLCA01_NLCB01_TT04_04_USFGRO0_WG16_16_01~", 1, 1, 1}
// };

/* runtime structures */
TensileStatus status;
hipStream_t stream;

void *deviceC;
void *deviceA;
void *deviceB;

/* benchmarking parameters */
size_t validationStride;
static bool useHighPrecisionAccumulate = false;

/* generated call to reference */
template<typename DataType, typename DestDataType>
TensileStatus generatedCallToReferenceCPU(
    const unsigned int *sizes,
    const unsigned int *minStrides,
    DestDataType *referenceC,
    DataType *initialA,
    DataType *initialB,
    const unsigned int stride_a,
    const unsigned int stride_b,
    const unsigned int stride_c,
    DestDataType alpha,
    DestDataType beta,
    bool useHighPrecisionAccumulate) {
  return tensileReferenceCPU(
      referenceC,
      initialA,
      initialB,
      stride_a,
      stride_b,
      stride_c,
      alpha,
      beta,
      totalIndices[problemTypeIdx],
      sizes,
      minStrides,
      numIndicesC[problemTypeIdx],
      numIndicesAB[problemTypeIdx],
      indexAssignmentsA[problemTypeIdx],
      indexAssignmentsB[problemTypeIdx],
      complexConjugateA[problemTypeIdx],
      complexConjugateB[problemTypeIdx],
      validationStride,
      useHighPrecisionAccumulate);
};

/* generated call to solution */
template<typename DataType>
TensileStatus generatedCallToSolution(
    unsigned int solutionIdx,
    const unsigned int *sizes,
    const unsigned int *minStrides,
    const unsigned int stride_a,
    const unsigned int stride_b,
    const unsigned int stride_c,
    DataType alpha,
    DataType beta, 
    unsigned int numEvents = 0, 
    hipEvent_t *startEvent = NULL,
    hipEvent_t *stopEvent = NULL ) {
  // calculate parameters assuming packed data
  unsigned int strideC0I = 1;
  unsigned int strideC1J = 1* std::max(minStrides[0], sizes[0]);
  unsigned int strideC2K = 1* std::max(minStrides[0], sizes[0])* std::max(minStrides[1], sizes[1]);
  if (stride_c != std::numeric_limits<unsigned int>::max())  strideC2K = stride_c;
  unsigned int strideA0I = 1;
  unsigned int strideA1L = 1* std::max(minStrides[0], sizes[0]);
  unsigned int strideA2K = 1* std::max(minStrides[0], sizes[0])* std::max(minStrides[3], sizes[3]);
  if (stride_a != std::numeric_limits<unsigned int>::max())  strideA2K = stride_a;
  unsigned int strideB0J = 1;
  unsigned int strideB1L = 1* std::max(minStrides[1], sizes[1]);
  unsigned int strideB2K = 1* std::max(minStrides[1], sizes[1])* std::max(minStrides[3], sizes[3]);
  if (stride_b != std::numeric_limits<unsigned int>::max())  strideB2K = stride_b;
  unsigned int sizeI = sizes[0];
  unsigned int sizeJ = sizes[1];
  unsigned int sizeK = sizes[2];
  unsigned int sizeL = sizes[3];

  // Check assertions,
  unsigned psem = 1; // problem summation element multiple
  if ((sizeL & 0x7) == 0) psem=8;
  else if ((sizeL & 0x3) == 0) psem=4;
  else if ((sizeL & 0x1) == 0) psem=2;

  unsigned pf0em = 1; // problem free0 element multiple
  if ((sizeI & 0x7) == 0) pf0em=8;
  else if ((sizeI & 0x3) == 0) pf0em=4;
  else if ((sizeI & 0x1) == 0) pf0em=2;

  unsigned pf1em = 1; // problem free1 element multiple
  if ((sizeJ & 0x7) == 0) pf1em=8;
  else if ((sizeJ & 0x3) == 0) pf1em=4;
  else if ((sizeJ & 0x1) == 0) pf1em=2;

if (!(
  (psem >= solutions[solutionIdx].assertSummationElementMultiple) &&
  (pf0em >= solutions[solutionIdx].assertFree0ElementMultiple) &&
  (pf1em >= solutions[solutionIdx].assertFree1ElementMultiple)
)) { return tensileStatusAssertFailure; } // failed solution requirements

  // call solution function
  auto f = solutions[solutionIdx].functionPtr;
  return f( static_cast<double *>(deviceC), static_cast<double *>(deviceA), static_cast<double *>(deviceB),
      alpha,
      beta,
      0, 0, 0, // offsets
      strideC1J,
      strideC2K,
      strideA1L,
      strideA2K,
      strideB1L,
      strideB2K,
      sizeI,
      sizeJ,
      sizeK,
      sizeL,
      stream,
      numEvents, startEvent, stopEvent); // events
};

/* results file name */
const char *resultsFileName = "/home/shchy/code/Tensile/build/1_BenchmarkProblems/Cijk_Ailk_Bjlk_DB_00/00_Final/sourceTmp/../../Data/00_Final.csv";
